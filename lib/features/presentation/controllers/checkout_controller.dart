import 'package:flutter/material.dart';
import 'package:get/get.dart';
import '../../data/models/order_model.dart';
import '../../data/models/order_status.dart';
import 'order_controller.dart';
import 'cart_controller.dart';
import '../../../core/utils/snackbar_utils.dart';

class CheckoutController extends GetxController {
  final OrderController _orderController = Get.find<OrderController>();
  final CartController _cartController = Get.find<CartController>();

  final RxBool isProcessingOrder = false.obs;
  final RxString selectedAddressId = ''.obs;
  final RxString selectedPaymentMethod = 'cash_on_delivery'.obs;

  // Payment method options
  final List<Map<String, dynamic>> paymentMethods = [
    {
      'id': 'cash_on_delivery',
      'name': 'Cash on Delivery',
      'icon': Icons.money,
      'description': 'Pay when your order is delivered',
    },
    {
      'id': 'credit_card',
      'name': 'Credit/Debit Card',
      'icon': Icons.credit_card,
      'description': 'Secure online payment',
    },
    {
      'id': 'upi',
      'name': 'UPI Payment',
      'icon': Icons.account_balance_wallet,
      'description': 'Pay using UPI apps',
    },
    {
      'id': 'net_banking',
      'name': 'Net Banking',
      'icon': Icons.account_balance,
      'description': 'Pay using your bank account',
    },
  ];

  void setSelectedAddress(String addressId) {
    selectedAddressId.value = addressId;
  }

  void setSelectedPaymentMethod(String paymentMethodId) {
    selectedPaymentMethod.value = paymentMethodId;
  }

  double get subtotal => _cartController.total;
  double get shippingFee => 0.0; // Free shipping for now
  double get total => subtotal + shippingFee;

  bool get canProceedToPayment =>
      selectedAddressId.value.isNotEmpty && _cartController.items.isNotEmpty;

  Future<bool> processOrder() async {
    print('CheckoutController: Starting processOrder');
    print('CheckoutController: canProceedToPayment = $canProceedToPayment');
    print('CheckoutController: selectedAddressId = ${selectedAddressId.value}');
    print(
      'CheckoutController: cart items count = ${_cartController.items.length}',
    );

    if (!canProceedToPayment) {
      print('CheckoutController: Cannot proceed to payment');
      SnackbarUtils.showError(
        'Please select an address and ensure cart is not empty',
      );
      return false;
    }

    try {
      isProcessingOrder.value = true;
      print('CheckoutController: Processing order...');

      // Convert cart items to order items
      final orderItems =
          _cartController.items
              .map(
                (cartItem) => OrderItem(
                  id: '', // Will be generated by database
                  orderId: '', // Will be set by repository
                  productId: cartItem.product.id,
                  quantity: cartItem.quantity,
                  price: cartItem.product.price,
                  selectedSize: cartItem.selectedSize,
                  selectedColor: cartItem.selectedColor,
                  createdAt: DateTime.now(),
                ),
              )
              .toList();

      print('CheckoutController: Created ${orderItems.length} order items');
      print('CheckoutController: Order total = $total');

      // Create the order
      final success = await _orderController.createOrder(
        addressId: selectedAddressId.value,
        paymentMethodId: selectedPaymentMethod.value,
        subtotal: subtotal,
        shippingFee: shippingFee,
        total: total,
        items: orderItems,
      );

      print('CheckoutController: Order creation success = $success');

      if (success) {
        print('CheckoutController: Clearing cart...');
        // Clear the cart after successful order creation
        await _cartController.clearCart();
        print('CheckoutController: Cart cleared successfully');
        return true;
      } else {
        print('CheckoutController: Order creation failed');
        return false;
      }
    } catch (e) {
      print('CheckoutController: Error processing order: $e');
      SnackbarUtils.showError('Failed to process order. Please try again.');
      return false;
    } finally {
      isProcessingOrder.value = false;
      print('CheckoutController: processOrder completed');
    }
  }

  Future<void> simulatePayment() async {
    try {
      isProcessingOrder.value = true;

      // Simulate payment processing delay
      await Future.delayed(const Duration(seconds: 2));

      // For non-COD payments, simulate payment gateway
      if (selectedPaymentMethod.value != 'cash_on_delivery') {
        // Simulate payment processing
        await Future.delayed(const Duration(seconds: 1));

        // For demo purposes, we'll assume payment is successful
        // In real implementation, this would integrate with actual payment gateway
      }

      // Process the order
      final success = await processOrder();

      if (success) {
        // Navigate to order confirmation
        Get.offNamed('/order-confirmation');
      }
    } catch (e) {
      print('Error in payment simulation: $e');
      SnackbarUtils.showError('Payment failed. Please try again.');
    } finally {
      isProcessingOrder.value = false;
    }
  }

  String getPaymentMethodName(String id) {
    final method = paymentMethods.firstWhere(
      (method) => method['id'] == id,
      orElse: () => {'name': 'Unknown'},
    );
    return method['name'];
  }

  IconData getPaymentMethodIcon(String id) {
    final method = paymentMethods.firstWhere(
      (method) => method['id'] == id,
      orElse: () => {'icon': Icons.payment},
    );
    return method['icon'];
  }

  void reset() {
    selectedAddressId.value = '';
    selectedPaymentMethod.value = 'cash_on_delivery';
    isProcessingOrder.value = false;
  }
}
